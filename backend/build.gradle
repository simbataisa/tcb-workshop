plugins {
    id 'java'
    id 'org.springframework.boot' version '3.3.4'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'jacoco'
    id 'com.google.cloud.tools.jib' version '3.4.5'
}

group = 'com.ahss'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories {
    mavenCentral()
}

dependencyManagement {
    imports {
        mavenBom "io.opentelemetry:opentelemetry-bom:1.41.0"
    }
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'

    // Lombok
    compileOnly 'org.projectlombok:lombok:1.18.30'
    annotationProcessor 'org.projectlombok:lombok:1.18.30'
    testCompileOnly 'org.projectlombok:lombok:1.18.30'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.30'
    // Micrometer Tracing + OpenTelemetry OTLP exporter
    implementation 'io.micrometer:micrometer-tracing-bridge-otel:1.3.5'
    implementation 'io.opentelemetry:opentelemetry-exporter-otlp'
    implementation 'io.opentelemetry:opentelemetry-api'
    implementation 'io.opentelemetry:opentelemetry-context'
    implementation 'org.springframework.boot:spring-boot-starter-aop'

    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0'
    implementation 'io.swagger.core.v3:swagger-annotations:2.2.21'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'
    implementation 'org.flywaydb:flyway-core:9.5.1'
    implementation 'io.hypersistence:hypersistence-utils-hibernate-63:3.8.3'
    runtimeOnly 'org.postgresql:postgresql:42.7.3'
    // H2 for integration testing
    runtimeOnly 'com.h2database:h2:2.2.224'

    // Kafka (for CloudEvents tracing propagation)
    implementation 'org.springframework.kafka:spring-kafka:3.2.4'
    implementation 'org.apache.kafka:kafka-clients:3.7.1'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testImplementation 'org.springframework.kafka:spring-kafka-test:3.2.4'
    // WireMock integration with Spring Boot tests
    testImplementation 'org.springframework.cloud:spring-cloud-contract-wiremock:4.1.3'
    // Spring Boot integration with Testcontainers
    testImplementation 'org.springframework.boot:spring-boot-testcontainers'
    // Testcontainers for PostgreSQL and JUnit 5 integration
    testImplementation 'org.testcontainers:junit-jupiter:1.20.2'
    testImplementation 'org.testcontainers:postgresql:1.20.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    // Allure test instrumentation
    testImplementation 'io.qameta.allure:allure-junit5:2.27.0'
    testImplementation 'io.qameta.allure:allure-java-commons:2.27.0'
    testImplementation 'io.qameta.allure:allure-assertj:2.27.0'
}

tasks.named('test') {
    useJUnitPlatform()
    systemProperty 'junit.jupiter.extensions.autodetection.enabled', 'true'
    systemProperty 'allure.results.directory', "$buildDir/allure-results"
    // Enable Allure lifecycle calls in helper utilities
    systemProperty 'allure.suppress', 'false'
}

jacoco {
    toolVersion = '0.8.11'
}

tasks.named('jacocoTestReport') {
    dependsOn tasks.named('test')
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
}

tasks.named('check') {
    dependsOn tasks.named('jacocoTestReport')
}

jacocoTestCoverageVerification {
    dependsOn tasks.named('test')
    violationRules {
        rule {
            element = 'BUNDLE'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.70
            }
        }
    }
}

tasks.named('check') {
    dependsOn tasks.named('jacocoTestCoverageVerification')
}

// Write coverage summary into Allure environment.properties so it shows in the report
tasks.register('writeCoverageToAllureEnv') {
    dependsOn tasks.named('jacocoTestReport')
    doLast {
        def xmlFile = file("$buildDir/reports/jacoco/test/jacocoTestReport.xml")
        if (!xmlFile.exists()) {
            logger.warn("Jacoco XML not found: ${xmlFile}")
            return
        }
        def text = xmlFile.getText('UTF-8')
        def counters = [:]
        def pattern = /<counter\s+type=\"([A-Z]+)\"\s+missed=\"(\d+)\"\s+covered=\"(\d+)\"\s*\/>/
        def matcher = (text =~ pattern)
        matcher.each { m ->
            def type = m[1]
            def missed = new BigDecimal(m[2])
            def covered = new BigDecimal(m[3])
            def total = missed.add(covered)
            def pct = total.compareTo(BigDecimal.ZERO) > 0 ? covered.divide(total, 4, java.math.RoundingMode.HALF_UP).multiply(new BigDecimal(100)) : BigDecimal.ZERO
            counters[type] = String.format('%.2f', pct)
        }
        def resultsDir = file("$buildDir/allure-results")
        resultsDir.mkdirs()
        def envFile = file(new File(resultsDir, 'environment.properties'))
        def lines = counters.collect { k, v -> "Coverage.${k}=${v}%" }
        // After allureGenerate, Jacoco report will be at: build/allure-report/jacoco/index.html
        // Note: Allure escapes HTML in environment values, so these won't be clickable
        // Use the purple "View Coverage Report" button at top-right of the report instead
        lines << "Coverage.Report.File=coverage.html"
        lines << "Coverage.Report.Direct=jacoco/index.html"
        lines << "Coverage.Report.Note=Click the purple button at top-right to view coverage"
        envFile.text = lines.join('\n')
        logger.lifecycle("Wrote coverage summary to ${envFile}")
    }
}

// Write Allure executor metadata so the report shows test executor information
tasks.register('writeAllureExecutor') {
    dependsOn tasks.named('test')
    doLast {
        def resultsDir = file("$buildDir/allure-results")
        resultsDir.mkdirs()
        def executorFile = file(new File(resultsDir, 'executor.json'))

        // Build identifiers
        def timestamp = new Date().format('yyyyMMdd-HHmmss')
        def buildOrder = System.getenv('ALLURE_BUILD_ORDER') ?: '1'
        def buildName = System.getenv('ALLURE_BUILD_NAME') ?: "Local Gradle Test ${timestamp}"
        def buildUrl = System.getenv('ALLURE_BUILD_URL') ?: ''
        def reportUrl = System.getenv('ALLURE_REPORT_URL') ?: ''
        def reportName = System.getenv('ALLURE_REPORT_NAME') ?: 'Allure Report'
        def executorName = System.getenv('ALLURE_EXECUTOR_NAME') ?: 'Local Gradle'
        def executorType = System.getenv('ALLURE_EXECUTOR_TYPE') ?: 'gradle'
        def dashboardUrl = System.getenv('ALLURE_DASHBOARD_URL') ?: ''

        def payload = [
            name      : executorName,
            type      : executorType,
            url       : dashboardUrl,
            buildOrder: buildOrder as Integer,
            buildName : buildName,
            buildUrl  : buildUrl,
            reportUrl : reportUrl,
            reportName: reportName,
            buildId   : timestamp
        ]

        executorFile.text = groovy.json.JsonOutput.prettyPrint(
                groovy.json.JsonOutput.toJson(payload)
        )
        logger.lifecycle("Wrote Allure executor to ${executorFile}")
    }
}

configurations {
    allureCommandline {
        transitive = false
    }
}

dependencies {
    allureCommandline 'io.qameta.allure:allure-commandline:2.27.0@zip'
}

tasks.register('unzipAllure', Copy) {
    def zipFile = configurations.allureCommandline.files.find { it.name.endsWith('.zip') }
    from { zipTree(zipFile) }
    into "$buildDir/allure-commandline"
}

// Preserve trend by copying previous report's history into current results
tasks.register('copyAllureHistory', Copy) {
    def historyDir = file("$buildDir/allure-report/history")
    onlyIf { historyDir.exists() }
    from(historyDir)
    into("$buildDir/allure-results/history")
}

tasks.register('copyJacocoToAllure', Copy) {
    dependsOn 'jacocoTestReport'
    from("$buildDir/reports/jacoco/test/html")
    into("$buildDir/allure-report/jacoco")
    // Only run if Jacoco report exists
    onlyIf { file("$buildDir/reports/jacoco/test/html").exists() }
    doLast {
        // Create a clickable landing page for Jacoco report
        def landingPage = file("$buildDir/allure-report/coverage.html")
        landingPage.text = """
            <!DOCTYPE html>
            <html>
            <head> 
                <meta charset="UTF-8">
                <meta http-equiv="refresh" content="0; url=jacoco/index.html">
                <title>Redirecting to Coverage Report...</title>
                <style>
                    body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
                    a { color: #4CAF50; text-decoration: none; font-size: 18px; }
                    a:hover { text-decoration: underline; }
                </style>
            </head>
            <body>
                <h2>Redirecting to Jacoco Coverage Report...</h2>
                <p>If you are not redirected automatically, <a href="jacoco/index.html">click here</a>.</p>
            </body>
            </html>"""
                    logger.lifecycle("Created coverage landing page at ${landingPage}")

                    // Inject clickable link into Allure index.html
                    def indexFile = file("$buildDir/allure-report/index.html")
                    if (indexFile.exists()) {
                        def content = indexFile.text
                        // Add a custom style and link banner at the top of the page
                        def customBanner = """
                <style>
                    #coverage-report-btn {
                        position: fixed !important;
                        top: 70px !important;
                        right: 20px !important;
                        z-index: 99999 !important;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
                        padding: 14px 24px !important;
                        border-radius: 8px !important;
                        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2) !important;
                        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif !important;
                        transition: all 0.3s ease !important;
                    }
                    #coverage-report-btn:hover {
                        transform: translateY(-2px) !important;
                        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3) !important;
                    }
                    #coverage-report-btn a {
                        color: white !important;
                        text-decoration: none !important;
                        font-weight: 600 !important;
                        font-size: 15px !important;
                        display: flex !important;
                        align-items: center !important;
                        gap: 10px !important;
                        white-space: nowrap !important;
                    }
                    #coverage-report-btn a:hover {
                        text-decoration: none !important;
                    }
                    #coverage-report-btn svg {
                        width: 22px !important;
                        height: 22px !important;
                        flex-shrink: 0 !important;
                    }
                </style>
                <div id="coverage-report-btn">
                    <a href="coverage.html" target="_blank">
                        ðŸ“Š Coverage Report
                    </a>
                </div>
            """
            // Insert the banner right after <body> tag
            content = content.replace('<body>', '<body>' + customBanner)
            indexFile.text = content
            logger.lifecycle("Injected clickable coverage button into Allure report")
        }
    }
}

// Attach the OpenTelemetry Java agent when running the app locally
tasks.named('bootRun') {
    // Send traces to local OTLP collector, and name the service
    environment 'OTEL_SERVICE_NAME', 'sharedservices-backend'
    environment 'OTEL_TRACES_EXPORTER', 'otlp'
    environment 'OTEL_EXPORTER_OTLP_ENDPOINT', 'http://localhost:4318'
    // Optional: reduce noise by disabling metrics from the agent
    environment 'OTEL_METRICS_EXPORTER', 'none'
    // Optional: disable logs export to avoid 404 warnings when collector logs pipeline is not configured
    environment 'OTEL_LOGS_EXPORTER', 'none'
}

// Convenience task to run with the OpenTelemetry Java agent attached
tasks.register('bootRunWithAgent', org.springframework.boot.gradle.tasks.run.BootRun) {
    group = 'application'
    description = 'Run the application with OpenTelemetry Java agent attached'
    // Explicitly set main class to avoid detection issues
    mainClass = 'com.ahss.SharedServicesApplication'
    classpath = sourceSets.main.runtimeClasspath
    jvmArgs "-javaagent:${file("${rootDir}/../otel-javaagent.jar")}"
    environment 'OTEL_SERVICE_NAME', 'sharedservices-backend'
    environment 'OTEL_TRACES_EXPORTER', 'otlp'
    environment 'OTEL_EXPORTER_OTLP_ENDPOINT', 'http://localhost:4318'
    environment 'OTEL_METRICS_EXPORTER', 'none'
    environment 'OTEL_LOGS_EXPORTER', 'none'
}

// Container image is built via Jib (see dockerBuild task)

// Jib configuration to build Docker image for local Docker daemon
jib {
    from {
        image = 'eclipse-temurin:21-jre'
        // Select platform dynamically. Default 'arm64' (Apple Silicon), switch to 'amd64' for Windows build task or property.
        def isWindowsBuildTask = gradle.startParameter.taskNames.any { it == 'dockerBuildWindows' }
        def jibTargetArch = (project.findProperty('jibTargetArch') ?: System.getenv('JIB_TARGET_ARCH') ?: (isWindowsBuildTask ? 'amd64' : 'arm64'))
        platforms {
            platform {
                architecture = jibTargetArch
                os = 'linux'
            }
        }
    }
    to {
        image = 'shared-services:0.0.1-SNAPSHOT'
        // tags can be added if desired, e.g., ['latest']
    }
    // Use the Spring Boot fat jar produced by build/bootJar
    containerizingMode = 'packaged'
    container {
        // Explicit main class for reliable entrypoint
        mainClass = 'com.ahss.SharedServicesApplication'
        // Expose app port for clarity (Compose maps externally)
        ports = ['8080']
        // Reasonable JVM defaults; can be tuned
        jvmFlags = ['-Xms512m', '-Xmx512m']
        creationTime = 'USE_CURRENT_TIMESTAMP'
    }
    // Ensure Jib finds the Docker CLI even if Gradle's PATH is limited
    dockerClient {
        // Prefer explicit property or env, then common macOS locations
        def propExec = System.getProperty('jib.dockerClient.executable')
        def envExec = System.getenv('DOCKER_CLI')
        def candidates = [
            propExec,
            envExec,
            '/usr/local/bin/docker',
            '/opt/homebrew/bin/docker',
            '/opt/local/bin/docker'
        ].find { it && file(it).exists() }
        if (candidates) {
            executable = candidates
        }
    }
    // Build to local Docker daemon
    // Note: we will invoke the 'jibDockerBuild' task via a composite task below
}

// Convenience task to build Windows-targeted image (linux/amd64)
tasks.register('dockerBuildWindows') {
    group = 'build'
    description = 'Build Docker image for Windows Docker Desktop (linux/amd64)'
    dependsOn 'build', 'jibDockerBuild'
}

// Composite task to ensure JAR is built before containerizing with Jib
tasks.register('dockerBuild') {
    group = 'build'
    description = 'Builds the Spring Boot Docker image using Jib into local Docker'
    dependsOn tasks.named('build')
    dependsOn tasks.named('jibDockerBuild')
}

// Fallback: build an image tarball when Docker CLI is unavailable
tasks.register('dockerBuildTar') {
    group = 'build'
    description = 'Builds a Docker image tarball using Jib (output: build/jib-image.tar)'
    dependsOn tasks.named('build')
    dependsOn tasks.named('jibBuildTar')
}

tasks.register('allureGenerate', Exec) {
    dependsOn 'unzipAllure', 'copyAllureCategories', 'copyAllureHistory', 'writeCoverageToAllureEnv', 'writeAllureExecutor'
    doFirst {
        def distDir = file("$buildDir/allure-commandline").listFiles().find { it.name.startsWith('allure-') && it.isDirectory() }
        workingDir distDir
        commandLine './bin/allure', 'generate', '--clean', "$buildDir/allure-results", '-o', "$buildDir/allure-report"
    }
    finalizedBy 'copyJacocoToAllure'
}

tasks.register('allureServe', Exec) {
    // First generate the report with the button, then serve it
    dependsOn 'allureGenerate'
    doFirst {
        def distDir = file("$buildDir/allure-commandline").listFiles().find { it.name.startsWith('allure-') && it.isDirectory() }
        workingDir distDir
        // Use 'open' to serve from the generated report directory instead of temp
        commandLine './bin/allure', 'open', "$buildDir/allure-report"
    }
}

tasks.register('copyAllureCategories', Copy) {
    dependsOn 'test'
    from('src/test/resources/categories.json')
    into("$buildDir/allure-results")
}